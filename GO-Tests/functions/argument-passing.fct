initialise-giving initialise-binding initialise-storing postpone-after-effect multithread scope
  ({"any" |-> values,
    "bool" |-> booleans,
    "int" |-> integers,
    "uint" |-> natural-numbers,
    "true" |-> true,
    "false" |-> false,
    "nil" |-> null,
    "print" |-> function closure print
                  (tuple-elements given),
    "make" |-> function closure else
                 (case-match
                    (tuple
                       (channels),
                     channel-create
                       (0)),
                  case-match
                    (tuple
                       (channels,
                        pattern-bind "N"),
                     checked when-true
                       (is-greater-or-equal
                          (bound "N",
                           0),
                        channel-create
                          (bound "N"))))},
   scope
     (collateral
        (bind
           ("main",
            allocate-variable functions
              (tuples
                 ((values)*),
               null-type)),
         bind
           ("my_print",
            allocate-variable functions
              (tuples
                 ((values)*),
               null-type)),
         map
           ( )),
      sequential
        (initialise-variable
           (bound "main",
            function closure scope
              (collateral
                 (match
                    (given,
                     tuple
                       ( )),
                  map
                    ( )),
               handle-return sequential
                 (apply
                    (current-value bound
                       "my_print",
                     tuple
                       (current-value bound
                          "true")),
                  null-value))),
         initialise-variable
           (bound "my_print",
            function closure scope
              (collateral
                 (match
                    (given,
                     tuple
                       (pattern closure bind
                          ("b",
                           alloc-init
                             (values,
                              given)))),
                  map
                    ( )),
               handle-return sequential
                 (apply
                    (current-value bound
                       "print",
                     tuple
                       (current-value bound
                          "b")),
                  null-value))),
         null-value,
         effect apply
           (current-value bound
              "main",
            tuple
              ( )))))