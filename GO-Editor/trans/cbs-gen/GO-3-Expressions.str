module GO-3-Expressions

imports
  libstratego-gpp
  signatures/-
  pp/GO-parenthesize
  pp/GO-pp

imports
  cbs-gen/GO-1-Lexemes

// Language "Golang"

rules

// #3 Expressions
              


// ## Operands
                 

to-funcons:
  |[ evaluate-operand[: (:Int-Lit:) :] ]| ->
  |[ integer-value[: (:Int-Lit:) :] ]|
to-funcons:
  |[ evaluate-operand[: (:Identifier:) :] ]| ->
  |[ sequential (check-true not is-in-type (bound identifier[: (:Identifier:) :], 
                                   types), 
             current-value bound identifier[: (:Identifier:) :]) ]|
to-funcons:
  |[ evaluate-operand[: ((:Expression:)) :] ]| ->
  |[ evaluate-expression[: (:Expression:) :] ]|

// ## Primary expressions
                 

to-funcons:
  |[ evaluate-primaryexpr[: (:Operand:) :] ]| ->
  |[ evaluate-operand[: (:Operand:) :] ]|
to-funcons:
  |[ evaluate-primaryexpr[: (:PrimaryExpr:)(:Arguments:) :] ]| ->
  |[ apply (evaluate-primaryexpr[: (:PrimaryExpr:) :], 
             evaluate-arguments[: (:Arguments:) :]) ]|

// ### Arguments
                 

to-funcons:
  |[ evaluate-arguments[: () :] ]| ->
  |[ tuple () ]|
to-funcons:
  |[ evaluate-arguments[: ((:ExpressionList:)) :] ]| ->
  |[ tuple (evaluate-expressionlist[: (:ExpressionList:) :]) ]|
to-funcons:
  |[ evaluate-arguments[: ((:ExpressionList:),) :] ]| ->
  |[ tuple (evaluate-expressionlist[: (:ExpressionList:) :]) ]|
to-funcons:
  |[ evaluate-expressionlist[: (:Expression:) :] ]| ->
  |[ evaluate-expression[: (:Expression:) :] ]|
to-funcons:
  |[ evaluate-expressionlist[: (:Expression:),(:ExpressionList:) :] ]| ->
  |[ evaluate-expression[: (:Expression:) :], 
     evaluate-expressionlist[: (:ExpressionList:) :] ]|

// ## Operators
                 


// ### Binary operators
                 

to-funcons:
  |[ evaluate-expression[: (:UnaryExpr:) :] ]| ->
  |[ evaluate-unaryexpr[: (:UnaryExpr:) :] ]|

// #### Boolean expressions
                 

to-funcons:
  |[ evaluate-expression[: (:Expression1:)||(:Expression2:) :] ]| ->
  |[ if-else (evaluate-expression[: (:Expression1:) :], 
             true, 
             evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)&&(:Expression2:) :] ]| ->
  |[ if-else (evaluate-expression[: (:Expression1:) :], 
             evaluate-expression[: (:Expression2:) :], 
             false) ]|

// #### Comparison expressions
                 

to-funcons:
  |[ evaluate-expression[: (:Expression1:)==(:Expression2:) :] ]| ->
  |[ is-eq l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)!=(:Expression2:) :] ]| ->
  |[ not is-eq l-to-r (evaluate-expression[: (:Expression1:) :], 
                           evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)<(:Expression2:) :] ]| ->
  |[ is-less l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)<=(:Expression2:) :] ]| ->
  |[ is-less-or-equal l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)>(:Expression2:) :] ]| ->
  |[ is-greater l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)>=(:Expression2:) :] ]| ->
  |[ is-greater-or-equal l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|

// #### Additive expressions
                 

to-funcons:
  |[ evaluate-expression[: (:Expression1:)+(:Expression2:) :] ]| ->
  |[ int-add l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)-(:Expression2:) :] ]| ->
  |[ integer-subtract l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|

// #### Multiplicative expressions
                 

to-funcons:
  |[ evaluate-expression[: (:Expression1:)*(:Expression2:) :] ]| ->
  |[ int-mul l-to-r (evaluate-expression[: (:Expression1:) :], 
                    evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)/(:Expression2:) :] ]| ->
  |[ checked int-div l-to-r (evaluate-expression[: (:Expression1:) :], 
                           evaluate-expression[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate-expression[: (:Expression1:)%(:Expression2:) :] ]| ->
  |[ checked int-mod l-to-r (evaluate-expression[: (:Expression1:) :], 
                           evaluate-expression[: (:Expression2:) :]) ]|

// ### Unary expressions
                 

to-funcons:
  |[ evaluate-unaryexpr[: (:PrimaryExpr:) :] ]| ->
  |[ evaluate-primaryexpr[: (:PrimaryExpr:) :] ]|
to-funcons:
  |[ evaluate-unaryexpr[: +(:UnaryExpr:) :] ]| ->
  |[ evaluate-unaryexpr[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate-unaryexpr[: -(:UnaryExpr:) :] ]| ->
  |[ integer-negate evaluate-unaryexpr[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate-unaryexpr[: !(:UnaryExpr:) :] ]| ->
  |[ not (evaluate-unaryexpr[: (:UnaryExpr:) :]) ]|

