module GO-3-Expressions

imports
  libstratego-gpp
  signatures/-
  pp/GO-parenthesize
  pp/GO-pp

imports
  cbs-gen/GO-1-Lexemes

// Language "Golang"

rules

// #3 Expressions
              


// ## Operands
                 

to-funcons:
  |[ evaluate[: (:Int-Lit:) :] ]| ->
  |[ integer-value[: (:Int-Lit:) :] ]|
to-funcons:
  |[ evaluate[: ((:Expression:)) :] ]| ->
  |[ evaluate[: (:Expression:) :] ]|

// ## Primary expressions
                 


// ## Operators
                 


// ### Binary operators
                 


// #### Boolean expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)||(:Expression2:) :] ]| ->
  |[ if-else (evaluate[: (:Expression1:) :], 
             true, 
             evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)&&(:Expression2:) :] ]| ->
  |[ if-else (evaluate[: (:Expression1:) :], 
             evaluate[: (:Expression2:) :], 
             false) ]|

// #### Comparison expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)==(:Expression2:) :] ]| ->
  |[ is-eq l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)!=(:Expression2:) :] ]| ->
  |[ not is-eq l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)<(:Expression2:) :] ]| ->
  |[ is-less l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)<=(:Expression2:) :] ]| ->
  |[ is-less-or-equal l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)>(:Expression2:) :] ]| ->
  |[ is-greater l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)>=(:Expression2:) :] ]| ->
  |[ is-greater-or-equal l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|

// #### Additive expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)+(:Expression2:) :] ]| ->
  |[ int-add l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)-(:Expression2:) :] ]| ->
  |[ int-sub l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|

// #### Multiplicative expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)*(:Expression2:) :] ]| ->
  |[ int-mul l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)/(:Expression2:) :] ]| ->
  |[ checked int-div l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)%(:Expression2:) :] ]| ->
  |[ checked int-mod l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|

// ### Unary expressions
                 

to-funcons:
  |[ evaluate[: +(:UnaryExpr:) :] ]| ->
  |[ evaluate[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate[: -(:UnaryExpr:) :] ]| ->
  |[ integer-negate evaluate[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate[: !(:UnaryExpr:) :] ]| ->
  |[ not (evaluate[: (:UnaryExpr:) :]) ]|

