module GO-3-Expressions

imports
  libstratego-gpp
  signatures/-
  pp/GO-parenthesize
  pp/GO-pp

imports
  cbs-gen/GO-1-Lexemes

// Language "Golang"

rules

// #3 Expressions
              


// ## Operands
                 

to-funcons:
  |[ evaluate[: (:Int-Lit:) :] ]| ->
  |[ integer-value[: (:Int-Lit:) :] ]|
to-funcons:
  |[ evaluate[: (:Identifier:) :] ]| ->
  |[ current-value bound id[: (:Identifier:) :] ]|
to-funcons:
  |[ evaluate[: ((:Expression:)) :] ]| ->
  |[ evaluate[: (:Expression:) :] ]|

// ## Primary expressions
                 

to-funcons:
  |[ evaluate[: (:Operand:) :] ]| ->
  |[ evaluate[: (:Operand:) :] ]|
to-funcons:
  |[ evaluate[: (:PrimaryExpr:)(:Arguments:) :] ]| ->
  |[ apply (evaluate[: (:PrimaryExpr:) :], 
             tuple-arguments[: (:Arguments:) :]) ]|

// ### Arguments
                 

to-funcons:
  |[ tuple-arguments[: () :] ]| ->
  |[ tuple () ]|
to-funcons:
  |[ tuple-arguments[: ((:ExpressionList:)) :] ]| ->
  |[ tuple l-to-r (evaluate-expressions[: (:ExpressionList:) :]) ]|
to-desugared:
  [: ((:ExpressionList:),) :] : arguments ->
  [: ((:ExpressionList:)) :] : arguments
to-funcons:
  |[ evaluate-expressions[: (:Expression:) :] ]| ->
  |[ evaluate[: (:Expression:) :] ]|
to-funcons:
  |[ evaluate-expressions[: (:Expression:),(:ExpressionList:) :] ]| ->
  |[ evaluate[: (:Expression:) :], 
     evaluate-expressions[: (:ExpressionList:) :] ]|

// ## Operators
                 


// ### Binary operators
                 


// #### Boolean expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)||(:Expression2:) :] ]| ->
  |[ or (evaluate[: (:Expression1:) :], 
             evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)&&(:Expression2:) :] ]| ->
  |[ and (evaluate[: (:Expression1:) :], 
             evaluate[: (:Expression2:) :]) ]|

// #### Comparison expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)==(:Expression2:) :] ]| ->
  |[ is-eq l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)!=(:Expression2:) :] ]| ->
  |[ not is-eq l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)<(:Expression2:) :] ]| ->
  |[ is-less l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)<=(:Expression2:) :] ]| ->
  |[ is-less-or-equal l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)>(:Expression2:) :] ]| ->
  |[ is-greater l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)>=(:Expression2:) :] ]| ->
  |[ is-greater-or-equal l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|

// #### Additive expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)+(:Expression2:) :] ]| ->
  |[ int-add l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)-(:Expression2:) :] ]| ->
  |[ integer-subtract l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|

// #### Multiplicative expressions
                 

to-funcons:
  |[ evaluate[: (:Expression1:)*(:Expression2:) :] ]| ->
  |[ int-mul l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)/(:Expression2:) :] ]| ->
  |[ checked int-div l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)%(:Expression2:) :] ]| ->
  |[ checked int-mod l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|

// ### Unary expressions
                 

to-funcons:
  |[ evaluate[: (:PrimaryExpr:) :] ]| ->
  |[ evaluate[: (:PrimaryExpr:) :] ]|
to-funcons:
  |[ evaluate[: +(:UnaryExpr:) :] ]| ->
  |[ evaluate[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate[: -(:UnaryExpr:) :] ]| ->
  |[ integer-negate evaluate[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate[: !(:UnaryExpr:) :] ]| ->
  |[ not evaluate[: (:UnaryExpr:) :] ]|

