module GO-3-Expressions

imports
  libstratego-gpp
  signatures/-
  pp/GO-parenthesize
  pp/GO-pp

imports
  cbs-gen/GO-1-Lexemes

// Language "Golang"

rules

// #3 Expressions
              


// ## Operand
                 

to-funcons:
  |[ evaluate[: (:IL:) :] ]| ->
  |[ integer-value[: (:IL:) :] ]|
to-funcons:
  |[ evaluate[: ((:Expression:)) :] ]| ->
  |[ evaluate[: (:Expression:) :] ]|

// ## Primary
                 


// ## Unary
                 

to-funcons:
  |[ evaluate[: +(:UnaryExpr:) :] ]| ->
  |[ evaluate[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate[: -(:UnaryExpr:) :] ]| ->
  |[ integer-negate evaluate[: (:UnaryExpr:) :] ]|
to-funcons:
  |[ evaluate[: !(:UnaryExpr:) :] ]| ->
  |[ not evaluate[: (:UnaryExpr:) :] ]|

// ## Binary
                 


// ### Boolean
                 

to-funcons:
  |[ evaluate[: (:Expression1:)||(:Expression2:) :] ]| ->
  |[ if-else (evaluate[: (:Expression1:) :], 
             true, 
             evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)&&(:Expression2:) :] ]| ->
  |[ if-else (evaluate[: (:Expression1:) :], 
             evaluate[: (:Expression2:) :], 
             false) ]|

// ### Comparison
                 

to-funcons:
  |[ evaluate[: (:Expression1:)==(:Expression2:) :] ]| ->
  |[ is-eq l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)!=(:Expression2:) :] ]| ->
  |[ not is-eq l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)<(:Expression2:) :] ]| ->
  |[ is-less l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)<=(:Expression2:) :] ]| ->
  |[ is-less-or-equal l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)>(:Expression2:) :] ]| ->
  |[ is-greater l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)>=(:Expression2:) :] ]| ->
  |[ is-greater-or-equal l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|

// ### Additive
                 

to-funcons:
  |[ evaluate[: (:Expression1:)+(:Expression2:) :] ]| ->
  |[ int-add l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)-(:Expression2:) :] ]| ->
  |[ int-sub l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|

// ### Multiplicative
                 

to-funcons:
  |[ evaluate[: (:Expression1:)*(:Expression2:) :] ]| ->
  |[ int-mul l-to-r (evaluate[: (:Expression1:) :], 
                    evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)/(:Expression2:) :] ]| ->
  |[ checked int-div l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|
to-funcons:
  |[ evaluate[: (:Expression1:)%(:Expression2:) :] ]| ->
  |[ checked int-mod l-to-r (evaluate[: (:Expression1:) :], 
                           evaluate[: (:Expression2:) :]) ]|

