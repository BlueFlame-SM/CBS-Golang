Language "Golang"

#3 Expressions

## Operands

Syntax
  Operand : operand
    ::= int-lit
//      | float-lit  // TODO: float
//      | imaginary-lit  // TODO: imaginary
//      | rune-lit  // TODO: runes
//      | string-lit  // TODO: strings
      | identifier // typeArgs?  // TODO: types
//      | qualifiedIdent typeArgs?  // TODO: packages
      | '(' expression ')'

Semantics
  evaluate-operand[[_:operand]] : =>values

Rule
  evaluate-operand[[Int-Lit]]
    = integer-value[[Int-Lit]]

Rule
  evaluate-operand[[Identifier]]
    = sequential(
        check-true not is-in-type(bound identifier[[Identifier]], types),
        current-value bound identifier[[Identifier]])

Rule
  evaluate-operand[['(' Expression ')']]
    = evaluate-expression[[Expression]]


## Primary expressions

Syntax
  PrimaryExpr : primaryExpr
    ::= operand
//      | type '(' expression ','? ')'  // TODO: types
//      | methodExpr  // TODO: methods
      // Selector
//      | primaryExpr '.' identifier  // TODO: structs
      // Index
//      | primaryExpr '[' expression ','? ']'  // TODO: arrays
      // Slice
//      | primaryExpr '[' expression? ':' expression? ']'  // TODO: slices
//      | primaryExpr '[' expression? ':' expression ':' expression ']'  // TODO: slices
      // TypeAssertion
//      | primaryExpr '.' '(' type ')'  // TODO: types
      // Arguments
      | primaryExpr arguments

Semantics
  evaluate-primaryexpr[[_:primaryExpr]] : =>values

Rule
  evaluate-primaryexpr[[Operand]] = evaluate-operand[[Operand]]

Rule
  evaluate-primaryexpr[[PrimaryExpr Arguments]]
    = apply(
        evaluate-primaryexpr[[PrimaryExpr]],
        evaluate-arguments[[Arguments]])


### Arguments

Syntax
  Arguments : arguments  // TODO: Variadic
    ::= '(' ')'
      | '(' expressionList ')'
      | '(' expressionList ',' ')'

Semantics
  evaluate-arguments[[_:arguments]] : =>tuple(values)

Rule
  evaluate-arguments[['(' ')']] = tuple( )

Rule
  evaluate-arguments[['(' ExpressionList ')']]
    = tuple(evaluate-expressionlist[[ExpressionList]])

Rule
  evaluate-arguments[['(' ExpressionList ',' ')']]
    = tuple(evaluate-expressionlist[[ExpressionList]])

Syntax
  ExpressionList : expressionList
    ::= expression
      | expression ',' expressionList

Semantics
  evaluate-expressionlist[[_:expressionList]] : =>values*

Rule
  evaluate-expressionlist[[Expression]] = evaluate-expression[[Expression]]

Rule
  evaluate-expressionlist[[Expression ',' ExpressionList]]
    = evaluate-expression[[Expression]], evaluate-expressionlist[[ExpressionList]]


## Operators

### Binary operators

Syntax
  Expression : expression
    ::= unaryExpr
      | expression '||' expression
      | expression '&&' expression
      // rel_op
      | expression '==' expression
      | expression '!=' expression
      | expression '<' expression
      | expression '<=' expression
      | expression '>' expression
      | expression '>=' expression
      // add_op
      | expression '+' expression
      | expression '-' expression
//      | expression '|' expression  // TODO: bitwise
//      | expression '^' expression  // TODO: bitwise
      // mul_op
      | expression '*' expression
      | expression '/' expression
      | expression '%' expression
//      | expression '<<' expression  // TODO: bitwise
//      | expression '>>' expression  // TODO: bitwise
//      | expression '&' expression  // TODO: bitwise
//      | expression '&^' expression  //TODO: bitwise

Semantics
  evaluate-expression[[_:expression]] : =>values

Rule
  evaluate-expression[[UnaryExpr]] = evaluate-unaryexpr[[UnaryExpr]]


#### Boolean expressions

Rule
  evaluate-expression[[Expression1 '||' Expression2]]
    = if-else(evaluate-expression[[Expression1]], true, evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '&&' Expression2]] =
    if-else(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]], false)


#### Comparison expressions

Rule
  evaluate-expression[[Expression1 '==' Expression2]]
    = is-eq l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '!=' Expression2]]
    = not is-eq l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '<' Expression2]]
    = is-less l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '<=' Expression2]]
    = is-less-or-equal l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '>' Expression2]]
    = is-greater l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '>=' Expression2]]
    = is-greater-or-equal l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])


#### Additive expressions

Rule
  evaluate-expression[[Expression1 '+' Expression2]]
    = int-add l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '-' Expression2]]
    = integer-subtract l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])


#### Multiplicative expressions

Rule
  evaluate-expression[[Expression1 '*' Expression2]]
    = int-mul l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '/' Expression2]]
    = checked int-div l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])

Rule
  evaluate-expression[[Expression1 '%' Expression2]]
    = checked int-mod l-to-r(evaluate-expression[[Expression1]], evaluate-expression[[Expression2]])


### Unary expressions

Syntax
  UnaryExpr : unaryExpr
    ::= primaryExpr
      | '+' unaryExpr
      | '-' unaryExpr
      | '!' unaryExpr
//      | '^' unaryExpr  // TODO: bitwise
//      | '*' unaryExpr  // TODO: pointers
//      | '&' unaryExpr  // TODO: pointers
//      | '<-' unaryExpr  // TODO: concurrency

Semantics
  evaluate-unaryexpr[[_:unaryExpr]] : =>values

Rule
  evaluate-unaryexpr[[PrimaryExpr]] = evaluate-primaryexpr[[PrimaryExpr]]

Rule
  evaluate-unaryexpr[['+' UnaryExpr]] = evaluate-unaryexpr[[UnaryExpr]]

Rule
  evaluate-unaryexpr[['-' UnaryExpr]] = integer-negate evaluate-unaryexpr[[UnaryExpr]]

Rule
  evaluate-unaryexpr[['!' UnaryExpr]] = not(evaluate-unaryexpr[[UnaryExpr]])
