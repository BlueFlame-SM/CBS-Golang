Language "Golang"

#3 Expressions

## Operands

Syntax
  Operand : operand
    ::= int-lit
//      | float-lit  // TODO: float
//      | imaginary-lit  // TODO: imaginary
//      | rune-lit  // TODO: runes
//      | string-lit  // TODO: strings
      | identifier // typeArgs?  // TODO: types
//      | qualifiedIdent typeArgs?  // TODO: packages
      | '(' expression ')'

Rule
  evaluate[[Int-Lit]] = integer-value[[Int-Lit]]

Rule
  evaluate[[Identifier]] = current-value bound id[[Identifier]]

Rule
  evaluate[['(' Expression ')']] = evaluate[[Expression]]


## Primary expressions

Syntax
  PrimaryExpr : primaryExpr
    ::= operand
//      | type '(' expression ','? ')'  // TODO: types
//      | methodExpr  // TODO: methods
      // Selector
//      | primaryExpr '.' identifier  // TODO: structs
      // Index
//      | primaryExpr '[' expression ','? ']'  // TODO: arrays
      // Slice
//      | primaryExpr '[' expression? ':' expression? ']'  // TODO: slices
//      | primaryExpr '[' expression? ':' expression ':' expression ']'  // TODO: slices
      // TypeAssertion
//      | primaryExpr '.' '(' type ')'  // TODO: types
      // Call
      | primaryExpr arguments

Rule
  evaluate[[Operand]] = evaluate[[Operand]]

Rule
  evaluate[[PrimaryExpr Arguments]]
    = apply(evaluate[[PrimaryExpr]], tuple-arguments[[Arguments]])


### Arguments

Syntax
  Arguments : arguments  // TODO: Variadic
    ::= '(' ')'
      | '(' typeExpr commaExpression* ')'
      | '(' expression commaExpression* ')'
      | '(' typeExpr commaExpression* ',' ')'
      | '(' expression commaExpression* ',' ')'

Rule
  [['(' TypeExpr CommaExpression* ',' ')']] : arguments = [['(' TypeExpr CommaExpression* ')']]

Rule
  [['(' Expression CommaExpression* ',' ')']] : arguments = [['(' Expression CommaExpression* ')']]

Semantics
  tuple-arguments[[_:arguments]] : =>tuple(values)

Rule
  tuple-arguments[['(' ')']] = tuple( )

Rule
  tuple-arguments[['(' Expression CommaExpression* ')']]
    = tuple l-to-r(evaluate[[Expression]], evaluate-expressions[[CommaExpression*]])

Rule
  tuple-arguments[['(' TypeExpr CommaExpression* ')']]
    = tuple l-to-r(type-construct[[TypeExpr]], evaluate-expressions[[CommaExpression*]])

Syntax
  CommaExpression : commaExpression ::= ',' expression

Semantics
  evaluate-expressions[[_:commaExpression*]] : =>values*

Rule
  evaluate-expressions[[ ]] = ( )

Rule
  evaluate-expressions[[',' Expression CommaExpression*]]
    = evaluate[[Expression]], evaluate-expressions[[CommaExpression*]]


## Operators

### Binary operators

Syntax
  Expression : expression
    ::= unaryExpr
      | expression '||' expression
      | expression '&&' expression
      | expression rel-op expression
      | expression add-op expression
      | expression mul-op expression

Semantics
  evaluate[[_:expression]] : =>values


#### Boolean expressions

Rule
  evaluate[[Expression1 '||' Expression2]]
    = or(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '&&' Expression2]]
    = and(evaluate[[Expression1]], evaluate[[Expression2]])


#### Comparison expressions

Rule
  evaluate[[Expression1 '==' Expression2]]
    = is-eq l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '!=' Expression2]]
    = not is-eq l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '<' Expression2]]
    = is-less l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '<=' Expression2]]
    = is-less-or-equal l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '>' Expression2]]
    = is-greater l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '>=' Expression2]]
    = is-greater-or-equal l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])


#### Additive expressions

Rule
  evaluate[[Expression1 '+' Expression2]]
    = int-add l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '-' Expression2]]
    = integer-subtract l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])


#### Multiplicative expressions

Rule
  evaluate[[Expression1 '*' Expression2]]
    = int-mul l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '/' Expression2]]
    = checked int-div l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '%' Expression2]]
    = checked int-mod l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])


### Unary expressions

Syntax
  UnaryExpr : unaryExpr ::= primaryExpr | unary-op unaryExpr

Rule
  evaluate[[PrimaryExpr]] = evaluate[[PrimaryExpr]]

Rule
  evaluate[['+' UnaryExpr]] = evaluate[[UnaryExpr]]

Rule
  evaluate[['-' UnaryExpr]] = integer-negate evaluate[[UnaryExpr]]

Rule
  evaluate[['!' UnaryExpr]] = not evaluate[[UnaryExpr]]

Rule
  evaluate[['<-' UnaryExpr]] = channel-recv-else-wait evaluate[[UnaryExpr]]
