Language "Golang"

#3 Expressions

## Operands

Syntax
  Operand : operand
    ::= int-lit
//      | float-lit  // TODO: float
//      | imaginary-lit  // TODO: imaginary
//      | rune-lit  // TODO: runes
//      | string-lit  // TODO: strings
      | identifier // typeArgs?  // TODO: types
//      | qualifiedIdent typeArgs?  // TODO: packages
      | '(' expression ')'

Rule
  evaluate[[Int-Lit]] = integer-value[[Int-Lit]]

Rule
  evaluate[[Identifier]] = current-value bound id[[Identifier]]

Rule
  evaluate[['(' Expression ')']] = evaluate[[Expression]]


## Primary expressions

Syntax
  PrimaryExpr : primaryExpr
    ::= operand
//      | type '(' expression ','? ')'  // TODO: types
//      | methodExpr  // TODO: methods
      // Selector
//      | primaryExpr '.' identifier  // TODO: structs
      // Index
//      | primaryExpr '[' expression ','? ']'  // TODO: arrays
      // Slice
//      | primaryExpr '[' expression? ':' expression? ']'  // TODO: slices
//      | primaryExpr '[' expression? ':' expression ':' expression ']'  // TODO: slices
      // TypeAssertion
//      | primaryExpr '.' '(' type ')'  // TODO: types
      // Arguments
      | primaryExpr arguments

Rule
  evaluate[[Operand]] = evaluate[[Operand]]

Rule
  evaluate[[PrimaryExpr Arguments]]
    = apply(evaluate[[PrimaryExpr]], tuple-arguments[[Arguments]])


### Arguments

Syntax
  Arguments : arguments  // TODO: Variadic
    ::= '(' ')'
      | '(' expressionList ')'
      | '(' expressionList ',' ')'

Semantics
  tuple-arguments[[_:arguments]] : =>tuple(values)

Rule
  tuple-arguments[['(' ')']] = tuple( )

Rule
  tuple-arguments[['(' ExpressionList ')']]
    = tuple l-to-r(evaluate-expressions[[ExpressionList]])

Rule
  [['(' ExpressionList ',' ')']] : arguments = [['(' ExpressionList ')']]

Syntax
  ExpressionList : expressionList ::= expression (',' expressionList)?

Semantics
  evaluate-expressions[[_:expressionList]] : =>values*

Rule
  evaluate-expressions[[Expression]] = evaluate[[Expression]]

Rule
  evaluate-expressions[[Expression ',' ExpressionList]]
    = evaluate[[Expression]], evaluate-expressions[[ExpressionList]]


## Operators

### Binary operators

Syntax
  Expression : expression
    ::= unaryExpr
      | expression '||' expression
      | expression '&&' expression
      // rel_op
      | expression '==' expression
      | expression '!=' expression
      | expression '<' expression
      | expression '<=' expression
      | expression '>' expression
      | expression '>=' expression
      // add_op
      | expression '+' expression
      | expression '-' expression
//      | expression '|' expression  // TODO: bitwise
//      | expression '^' expression  // TODO: bitwise
      // mul_op
      | expression '*' expression
      | expression '/' expression
      | expression '%' expression
//      | expression '<<' expression  // TODO: bitwise
//      | expression '>>' expression  // TODO: bitwise
//      | expression '&' expression  // TODO: bitwise
//      | expression '&^' expression  //TODO: bitwise

Semantics
  evaluate[[_:expression]] : =>values


#### Boolean expressions

Rule
  evaluate[[Expression1 '||' Expression2]]
    = or(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '&&' Expression2]]
    = and(evaluate[[Expression1]], evaluate[[Expression2]])


#### Comparison expressions

Rule
  evaluate[[Expression1 '==' Expression2]]
    = is-eq l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '!=' Expression2]]
    = not is-eq l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '<' Expression2]]
    = is-less l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '<=' Expression2]]
    = is-less-or-equal l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '>' Expression2]]
    = is-greater l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '>=' Expression2]]
    = is-greater-or-equal l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])


#### Additive expressions

Rule
  evaluate[[Expression1 '+' Expression2]]
    = int-add l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '-' Expression2]]
    = integer-subtract l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])


#### Multiplicative expressions

Rule
  evaluate[[Expression1 '*' Expression2]]
    = int-mul l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '/' Expression2]]
    = checked int-div l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])

Rule
  evaluate[[Expression1 '%' Expression2]]
    = checked int-mod l-to-r(evaluate[[Expression1]], evaluate[[Expression2]])


### Unary expressions

Syntax
  UnaryExpr : unaryExpr
    ::= primaryExpr
      | '+' unaryExpr
      | '-' unaryExpr
      | '!' unaryExpr
//      | '^' unaryExpr  // TODO: bitwise
//      | '*' unaryExpr  // TODO: pointers
//      | '&' unaryExpr  // TODO: pointers
//      | '<-' unaryExpr  // TODO: concurrency

Rule
  evaluate[[PrimaryExpr]] = evaluate[[PrimaryExpr]]

Rule
  evaluate[['+' UnaryExpr]] = evaluate[[UnaryExpr]]

Rule
  evaluate[['-' UnaryExpr]] = integer-negate evaluate[[UnaryExpr]]

Rule
  evaluate[['!' UnaryExpr]] = not evaluate[[UnaryExpr]]
