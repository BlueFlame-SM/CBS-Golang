Language "Golang"

#4 Statements

Syntax
  Statement : statement
    ::= simpleStmt
      | declaration
//      | labeledStmt  // TODO: goto
//      | goStmt  // TODO: concurrency
//      | returnStmt  // TODO: functions
//      | breakStmt  // TODO: loops
//      | continueStmt  // TODO: loops
//      | gotoStmt  // TODO: goto
//      | fallThroughStmt  // TODO: ?
      | block
      | ifStmt
//      | switchStmt  // TODO: switch
//      | selectStmt  // TODO: concurrency
      | forStmt
//      | deferStmt  // TODO: concurrency
      | printStmt

Syntax
  SimpleStmt : simpleStmt
    ::= emptyStmt
      | expressionStmt
//      | sendStmt  // TODO: concurrency
      | incDecStmt
      | assignment
      | shortVarDecl

Syntax
  StatementSC  : statementSC  ::= statement ';'
  SimpleStmtSC : simpleStmtSC ::= simpleStmt ';'

Semantics
  execute[[_:statement]] : =>null-type


## Empty statements

Syntax
  emptyStmt ::= ( )

Rule
  execute[[ ]] = null-value


## Blocks

Syntax
  Block : block ::= '{' statementSC* '}'

Rule
  execute[['{' StatementSC* '}']]
    = scope(allocate-stmts[[StatementSC*]], execute-stmts[[StatementSC*]])

Semantics
  allocate-stmts[[_:statementSC*]] : =>envs

Rule
  allocate-stmts[[ ]] = map( )

Rule
  allocate-stmts[[VarDecl ';' StatementSC*]]
    = collateral(allocate-vars[[VarDecl]], allocate-stmts[[StatementSC*]])

Otherwise
  allocate-stmts[[Statement ';' StatementSC*]]
    = allocate-stmts[[StatementSC*]]

Semantics
  execute-stmts[[_:statementSC*]] : =>null-type

Rule
  execute-stmts[[ ]] = null-value

Rule
  execute-stmts[[VarDecl ';' StatementSC*]]
    = sequential(initialise-vars[[VarDecl]], execute-stmts[[StatementSC*]])

Otherwise
  execute-stmts[[Statement ';' StatementSC*]]
    = sequential(execute[[Statement]], execute-stmts[[StatementSC*]])


## Expression statements

Syntax
  expressionStmt ::= expression

Rule
  execute[[Expression]] = evaluate[[Expression]]


## IncDec statements

Syntax
  incDecStmt
    ::= identifier '++'
      | identifier '--'

Rule
  [[Identifier '++']] : statement
    = [[Identifier '+=' '1']]

Rule
  [[Identifier '--']] : statement
    = [[Identifier '-=' '1']]


## Assignment statements

Syntax
  assignment  // TODO: expression resolution, multiple assignment
    ::= identifier '=' expression
      | identifier '+=' expression
      | identifier '-=' expression
      | identifier '*=' expression
      | identifier '/=' expression
      | identifier '%=' expression

Rule
  execute[[Identifier '=' Expression]]
    = assign(bound(identifier[[Identifier]]), evaluate[[Expression]])

Rule
  [[Identifier '+=' Expression]] : assignment
    = [[Identifier '=' Identifier '+' '(' Expression ')']]

Rule
  [[Identifier '-=' Expression]] : assignment
    = [[Identifier '=' Identifier '-' '(' Expression ')']]

Rule
  [[Identifier '*=' Expression]] : assignment
    = [[Identifier '=' Identifier '*' '(' Expression ')']]

Rule
  [[Identifier '/=' Expression]] : assignment
    = [[Identifier '=' Identifier '/' '(' Expression ')']]

Rule
  [[Identifier '%=' Expression]] : assignment
    = [[Identifier '=' Identifier '%' '(' Expression ')']]


## Declarations

Syntax
  declaration
    ::= varDecl
//      | constDecl  // TODO: const
//      | typeDecl  // TODO: types

  topLevelDecl
    ::= declaration
//      | functionDecl  // TODO: functions
//      | methodDecl  // TODO: methods


### Constant declarations
// Skipped in favour of short variable declarations

//Syntax
//  constDecl ::= 'const' (constSpec | '(' (constSpec ';')* ')')
//  constSpec ::= identifierList (type? '=' expressionList)?
//
//Syntax
//  identifierList ::= identifier (',' identifier)*
//  expressionList ::= expression (',' expression)*


### Variable declarations

Syntax  // TODO: multiple assignment, multiple declares, types
  VarDecl : varDecl ::= 'var' varSpec
            varSpec ::= identifier '=' expression

Semantics
  allocate-vars[[_:varDecl]] : =>envs

Rule
  allocate-vars[['var' Identifier '=' Expression]]
    = bind(identifier[[Identifier]], alloc(values))

Semantics
  initialise-vars[[_:varDecl]] : =>envs

Rule
  initialise-vars[['var' Identifier '=' Expression]]
    = assign(bound(identifier[[Identifier]]), evaluate[[Expression]])


### Short variable declarations

Syntax
  shortVarDecl ::= identifier ':=' expression  // TODO: multiple assignment

Rule
  [[Identifier ':=' Expression]] : statement
    = [['var' Identifier '=' Expression]]


## If statements

Syntax
  IfStmt : ifStmt  // TODO: Initializer
    ::= 'if' expression block
      | 'if' expression block 'else' block
      | 'if' expression block 'else' ifStmt

Rule
  [['if' Expression Block]] : ifStmt
    = [['if' Expression Block 'else' '{' '}']]

Rule
  execute[['if' Expression Block1 'else' Block2]]
    = if-else(evaluate[[Expression]], execute[[Block1]], execute[[Block2]])

Rule
  execute[['if' Expression Block 'else' IfStmt]]
    = if-else(evaluate[[Expression]], execute[[Block]], execute[[IfStmt]])


## For statements

Syntax  // TODO: range clause
  ForStmt : forStmt
    ::= 'for' block
      | 'for' expression block
      | 'for' simpleStmt? ';' expression? ';' simpleStmt? block

Rule
  execute[['for' Block]] = while(true, execute[[Block]])

Rule
  execute[['for' Expression Block]] = while(evaluate[[Expression]], execute[[Block]])

Rule
  [['for' SimpleStmt1 ';' Expression ';' SimpleStmt2 '{' StatementSC* '}']] : statement
    = [['{' SimpleStmt1 ';' 'for' Expression '{' StatementSC* SimpleStmt2 ';' '}' ';' '}']]

Rule
  [['for' SimpleStmt1 ';' ';' SimpleStmt2 '{' StatementSC* '}']] : statement
    = [['{' SimpleStmt1 ';' 'for' '{' StatementSC* SimpleStmt2 ';' '}' ';' '}']]


## Temporary print statement

Syntax
  printStmt ::= 'print' '(' expression ')'

Rule
  execute[['print' '(' Expression ')']]
    = print(evaluate[[Expression]])









