Language "Golang"

#4 Statements

Syntax
  Statement : statement
    ::= simpleStmt
      | declaration
//      | labeledStmt  // TODO: goto
      | goStmt
      | returnStmt
//      | breakStmt  // TODO: loops
//      | continueStmt  // TODO: loops
//      | gotoStmt  // TODO: goto
//      | fallThroughStmt  // TODO: ?
      | block
      | ifStmt
//      | switchStmt  // TODO: switch
//      | selectStmt  // TODO: concurrency
      | forStmt
//      | deferStmt  // TODO: concurrency

Semantics
  execute[[_:statement]] : =>null-type


## GO statement

Syntax
  goStmt ::= 'go' primaryExpr arguments

Rule
  execute[['go' PrimaryExpr Arguments]]
    = thread-detach thread-activate thread-joinable
        supply(evaluate[[PrimaryExpr]], tuple-arguments[[Arguments]])


## Return statement

Syntax
  returnStmt ::= 'return' expression?

Rule
  execute[['return']] = return null

Rule
  execute[['return' Expression]] = return evaluate[[Expression]]

## Blocks

Syntax
  Block          : block          ::= '{' statementSemic* '}'
  StatementSemic : statementSemic ::= statement ';'

Rule
  execute[['{' StatementSemic* '}']]
    = scope(
        collateral(allocate-statements[[StatementSemic*]]),
        sequential(execute-statements[[StatementSemic*]]))

Semantics
  allocate-statements[[_:statementSemic*]] : =>environments*

Rule
  allocate-statements[[ ]] = ( )

Rule
  allocate-statements[[VarDecl ';' StatementSemic*]]
    = allocate[[VarDecl]], allocate-statements[[StatementSemic*]]

Otherwise
  allocate-statements[[Statement ';' StatementSemic*]]
    = allocate-statements[[StatementSemic*]]

Semantics
  execute-statements[[_:statementSemic*]] : (=>null-type)+

Rule
  execute-statements[[ ]] = null-value

Rule
  execute-statements[[Statement ';' StatementSemic*]]
    = execute[[Statement]], execute-statements[[StatementSemic*]]


## If statements

Syntax
  IfStmt : ifStmt
    ::= 'if' expression block
      | 'if' expression block 'else' block
      | 'if' expression block 'else' ifStmt
      | 'if' simpleStmt ';' expression block
      | 'if' simpleStmt ';' expression block 'else' block
      | 'if' simpleStmt ';' expression block 'else' ifStmt

Rule
  [['if' Expression Block]] : ifStmt
    = [['if' Expression Block 'else' '{' '}']]

Rule
  execute[['if' Expression Block1 'else' Block2]]
    = if-else(evaluate[[Expression]], execute[[Block1]], execute[[Block2]])

Rule
  execute[['if' Expression Block 'else' IfStmt]]
    = if-else(evaluate[[Expression]], execute[[Block]], execute[[IfStmt]])

Rule
  [['if' SimpleStmt ';' Expression Block]] : statement
    = [['{' SimpleStmt ';' 'if' Expression Block ';' '}']]

Rule
  [['if' SimpleStmt ';' Expression Block1 'else' Block2]] : statement
    = [['{' SimpleStmt ';' 'if' Expression Block1 'else' Block2 ';' '}']]

Rule
  [['if' SimpleStmt ';' Expression Block 'else' IfStmt]] : statement
    = [['{' SimpleStmt ';' 'if' Expression Block 'else' IfStmt ';' '}']]


## For statements

Syntax  // TODO: range clause
  ForStmt : forStmt
    ::= 'for' block
      | 'for' expression block
      | 'for' simpleStmt ';' expression? ';' simpleStmt block

Rule
  execute[['for' Block]] = while(true, execute[[Block]])

Rule
  execute[['for' Expression Block]] = while(evaluate[[Expression]], execute[[Block]])

Rule
  [['for' SimpleStmt1 ';' Expression ';' SimpleStmt2 '{' StatementSemic* '}']] : statement
    = [['{' SimpleStmt1 ';' 'for' Expression '{' StatementSemic* SimpleStmt2 ';' '}' ';' '}']]

Rule
  [['for' SimpleStmt1 ';' ';' SimpleStmt2 '{' StatementSemic* '}']] : statement
    = [['{' SimpleStmt1 ';' 'for' '{' StatementSemic* SimpleStmt2 ';' '}' ';' '}']]


## Simple Statements

Syntax
  SimpleStmt : simpleStmt
    ::= emptyStmt
      | expressionStmt
      | sendStmt
      | incDecStmt
      | assignment
      | shortVarDecl


### Empty statements

Syntax
  emptyStmt ::= ( )

Rule
  execute[[ ]] = null-value


### Expression statements

Syntax
  expressionStmt ::= expression

Rule
  execute[[Expression]] = evaluate[[Expression]]


### Send statements

Syntax
  sendStmt ::= identifier '<-' expression

Rule
  execute[[Identifier '<-' Expression]]
    = channel-send-else-wait(evaluate[[Identifier]], evaluate[[Expression]])


### IncDec statements

Syntax
  incDecStmt
    ::= identifier '++'
      | identifier '--'

Rule
  [[Identifier '++']] : statement
    = [[Identifier '+=' '1']]

Rule
  [[Identifier '--']] : statement
    = [[Identifier '-=' '1']]


### Assignment statements

Syntax
  Assignment : assignment ::= identifier assign-op expression  // TODO: expression resolution, multiple assignment

Rule
  execute[[Assignment]] = assign[[Assignment]]

Semantics
  assign[[_:assignment]] : =>null-type

Rule
  assign[[Identifier '=' Expression]]
    = assign(bound id[[Identifier]], evaluate[[Expression]])

Rule
  [[Identifier '+=' Expression]] : assignment
    = [[Identifier '=' Identifier '+' '(' Expression ')']]

Rule
  [[Identifier '-=' Expression]] : assignment
    = [[Identifier '=' Identifier '-' '(' Expression ')']]

Rule
  [[Identifier '*=' Expression]] : assignment
    = [[Identifier '=' Identifier '*' '(' Expression ')']]

Rule
  [[Identifier '/=' Expression]] : assignment
    = [[Identifier '=' Identifier '/' '(' Expression ')']]

Rule
  [[Identifier '%=' Expression]] : assignment
    = [[Identifier '=' Identifier '%' '(' Expression ')']]


### Short variable declarations

Syntax
  shortVarDecl ::= identifier ':=' expression  // TODO: multiple assignment

Rule
  [[Identifier ':=' Expression]] : statement
    = [['var' Identifier '=' Expression]]
