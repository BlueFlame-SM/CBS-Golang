Language "Golang"

#4 Statements

Syntax
  Statement : statement
    ::= simpleStmt
      | declaration
//      | labeledStmt  // TODO: goto
//      | goStmt  // TODO: concurrency
//      | returnStmt  // TODO: functions
//      | breakStmt  // TODO: loops
//      | continueStmt  // TODO: loops
//      | gotoStmt  // TODO: goto
//      | fallThroughStmt  // TODO: ?
      | block
      | ifStmt
//      | switchStmt  // TODO: switch
//      | selectStmt  // TODO: concurrency
//      | forStmt  // TODO: loops
//      | deferStmt  // TODO: concurrency
      | printStmt

Syntax
  SimpleStmt : simpleStmt
    ::= emptyStmt
      | expressionStmt
//      | sendStmt  // TODO: concurrency
//      | incDecStmt  // TODO: incdec
//      | assignment  // TODO: assignment
//      | shortVarDecl

Syntax
  StatementSC  : statementSC  ::= statement ';'
  SimpleStmtSC : simpleStmtSC ::= simpleStmt ';'

Semantics
  execute[[_:statement]] : =>null-type


## Empty statements

Syntax
  emptyStmt ::= ( )

Rule
  execute[[ ]] = null-value


## Blocks

Syntax
  Block : block ::= '{' statementSC* '}'

Rule
  execute[['{' StatementSC* '}']]
    = scope(allocate-stmts[[StatementSC*]], execute-stmts[[StatementSC*]])

Semantics
  allocate-stmts[[_:statementSC*]] : =>envs

Rule
  allocate-stmts[[ ]] = map( )

Rule
  allocate-stmts[[VarDecl ';' StatementSC*]]
    = collateral(allocate-vars[[VarDecl]], allocate-stmts[[StatementSC*]])

Otherwise
  allocate-stmts[[Statement ';' StatementSC*]]
    = allocate-stmts[[StatementSC*]]

Semantics
  execute-stmts[[_:statementSC*]] : =>null-type

Rule
  execute-stmts[[ ]] = null-value

Rule
  execute-stmts[[VarDecl ';' StatementSC*]]
    = sequential(initialise-vars[[VarDecl]], execute-stmts[[StatementSC*]])

Otherwise
  execute-stmts[[Statement ';' StatementSC*]]
    = sequential(execute[[Statement]], execute-stmts[[StatementSC*]])


## Expression statements

Syntax
  expressionStmt ::= expression

Rule
  execute[[Expression]] = evaluate[[Expression]]


## Assignment statements
// Skipped in favour of short variable declarations

//Syntax
//  assignment ::= identifier '=' expression  // TODO: expression resolution, multiple assignment, augmented assignment


## Declarations

Syntax
  declaration
    ::= varDecl
//      | constDecl  // TODO: const
//      | typeDecl  // TODO: types

  topLevelDecl
    ::= declaration
//      | functionDecl  // TODO: functions
//      | methodDecl  // TODO: methods


### Constant declarations
// Skipped in favour of short variable declarations

//Syntax
//  constDecl ::= 'const' (constSpec | '(' (constSpec ';')* ')')
//  constSpec ::= identifierList (type? '=' expressionList)?
//
//Syntax
//  identifierList ::= identifier (',' identifier)*
//  expressionList ::= expression (',' expression)*


### Variable declarations

Syntax  // TODO: multiple assignment, multiple declares, types
  VarDecl : varDecl ::= 'var' varSpec
            varSpec ::= identifier '=' expression

Semantics
  allocate-vars[[_:varDecl]] : =>envs

Rule
  allocate-vars[['var' Identifier '=' Expression]]
    = bind(identifier[[Identifier]], alloc(values))

Semantics
  initialise-vars[[_:varDecl]] : =>envs

Rule
  initialise-vars[['var' Identifier '=' Expression]]
    = assign(bound(identifier[[Identifier]]), evaluate[[Expression]])


### Short variable declarations

//Syntax
//  ShortVarDecl : shortVarDecl ::= identifier ':=' expression  // TODO: multiple assignment


## If statements

Syntax
  IfStmt : ifStmt  // TODO: Initializer
    ::= 'if' expression block
      | 'if' expression block 'else' block
      | 'if' expression block 'else' ifStmt

Rule
  [['if' Expression Block]] : ifStmt
    = [['if' Expression Block 'else' '{' '}']]

Rule
  execute[['if' Expression Block1 'else' Block2]]
    = if-else(evaluate[[Expression]], execute[[Block1]], execute[[Block2]])

Rule
  execute[['if' Expression Block 'else' IfStmt]]
    = if-else(evaluate[[Expression]], execute[[Block]], execute[[IfStmt]])


## For statements

//Syntax
//  ForStmt : forStmt ::= 'for' (expression | forClause)? block  // TODO: range clause


### For statements with for clause

//Syntax
//  forClause ::= simpleStmt? ';' expression? ';' simpleStmt?  // initStmt? ';' condition? ';' postStmt?


## Temporary print statement

Syntax
  printStmt ::= 'print' '(' expression ')'

Rule
  execute[['print' '(' Expression ')']]
    = print(evaluate[[Expression]])









