Language "Golang"

[
  #1 Lexical
  #2 Types
  #3 Expressions
  #4 Statements
  #5 Declarations
  #A Disambiguation
  #B Funcons
]

Syntax
  START : start ::= sourceFile

Semantics
  start[[START:start]] : =>strings

Rule
  start[[SourceFile]]
    = initialise-giving
      initialise-binding
      initialise-storing
      postpone-after-effect
      multithread
      scope(
        {
          // Types:
          "any"     |-> values,
          "bool"    |-> booleans,
          "int"     |-> integers,
          "uint"    |-> natural-numbers,
          // Constants:
          "true"    |-> true,
          "false"   |-> false,
          // Zero value:
          "nil"     |-> null,
          "print"   |-> function closure print to-strings tuple-elements given,
          "println" |-> function closure print to-strings(intersperse(" ", tuple-elements given), "\n"),
          "make"    |-> function closure else(
                          case-match(
                            tuple(channels),
                            channel-create(0)),
                          case-match(
                            tuple(
                              channels,
                              pattern-bind "N"),
                            checked when-true(
                              is-greater-or-equal(bound "N", 0),
                              channel-create(bound "N"))))
        },
        execute-sourcefile[[SourceFile]])

Syntax
  SourceFile        : sourceFile        ::= 'package' identifier ';' topLevelDeclSemic*
  TopLevelDeclSemic : topLevelDeclSemic ::= topLevelDecl ';'

Semantics
  execute-sourcefile[[_:sourceFile]] : =>null-value

Rule
  execute-sourcefile[['package' 'main' ';' TopLevelDeclSemic*]]
    = scope(
        collateral(allocate-topleveldecls[[TopLevelDeclSemic*]]),
        sequential(
          initialise-topleveldecls[[TopLevelDeclSemic*]],  // TODO: loop assign
          effect evaluate[['main' '(' ')']]))

Otherwise
  execute-sourcefile[['package' Identifier ';' TopLevelDeclSemic*]]
    = scope(
        collateral(allocate-topleveldecls[[TopLevelDeclSemic*]]),
        sequential(initialise-topleveldecls[[TopLevelDeclSemic*]]))

Semantics
  allocate-topleveldecls[[_:topLevelDeclSemic*]] : (=>environments)*

Rule
  allocate-topleveldecls[[ ]] = ( )

Rule
  allocate-topleveldecls[[TopLevelDecl ';' TopLevelDeclSemic*]]
    = allocate[[TopLevelDecl]], allocate-topleveldecls[[TopLevelDeclSemic*]]

Semantics
  initialise-topleveldecls[[_:topLevelDeclSemic*]] : (=>null-value)+

Rule
  initialise-topleveldecls[[ ]] = null-value

Rule
  initialise-topleveldecls[[TopLevelDecl ';' TopLevelDeclSemic*]]
    = initialise[[TopLevelDecl]], initialise-topleveldecls[[TopLevelDeclSemic*]]





