Language "Golang"

#B Funcons

Meta-variables
  T <: values

## Flowing

Funcon
  passthrough(Res:=>T, Comp*:(=>null-value)*) : =>T
     ~> give(Res, sequential(Comp*, given))


## Lists

Funcon
  list-snoc(_:lists(T), _:T) : => lists(T)

Rule
  list-snoc([V*:values*], V:values) ~> [V*, V]

Funcon
  list-init(_:lists(T)) : =>(lists(T))?

Rule
  list-init[V*:values*, _:values] ~> [V*]

Rule
  list-init[ ] ~> ( )

Funcon
  list-last(_:lists(T)) : =>(T)?

Rule
  list-last[_*:values*, V:values] ~> V

Rule
  list-last[ ] ~> ( )


## Integers

//Alias
//  int-sub = integer-subtract


## Variables

Funcon
  variable-type(_:variables) : =>types

Rule
  variable-type variable(_:locations, T:types) ~> T


## Typeconstructs

Datatype
  type-constructs
    ::= {_:types} | type-construct(_:types, _:type-constructs*)

Funcon
  type-construct-type(_:type-constructs) : =>types

Rule
  type-construct-type(T:types) ~> T

Rule
  type-construct-type(type-construct(T:types, _*:type-constructs*)) ~> T

Funcon
  type-construct-args(_:type-constructs) : =>types*

Rule
  type-construct-args(_:types) ~> ( )

Rule
  type-construct-args(type-construct(_, Args*)) ~> Args*


## Channels

Datatype
  channels ::= channel(_:vars, _:vars, _:vars, _:syncs, _:syncs, _:syncs)

Funcon
  channel-create(T:types, N:nats) : =>channels
     ~> channel(
          alloc-init(lists(T), [ ]),
          alloc-init(nats, N),
          alloc-init(bools, false),
          condition-create,
          condition-create,
          exclusive-lock-create)

Funcon
  channel-await-send(_:channels, _:syncs) : =>null-type

Rule
  channel-await-send channel(_, _, _, AwaitingSend, _, Mutex)
     ~> condition-wait-with-lock(AwaitingSend, Mutex)

Funcon
  channel-await-recv(_:channels, _:syncs) : =>null-type

Rule
  channel-await-recv channel(_, _, _, _, AwaitingRecv, Mutex)
     ~> condition-wait-with-lock(AwaitingRecv, Mutex)

Funcon
  channel-sync-else-wait(_:channels) : =>null-type

Rule
  channel-sync-else-wait channel(_, _, _, _, _, Mutex)
     ~> exclusive-lock-sync-else-wait Mutex

Funcon
  channel-release(_:channels) : =>null-type

Rule
  channel-release channel(_, _, _, _, _, Mutex)
     ~> exclusive-lock-release(Mutex)

Funcon
  channel-closed(_:channels) : =>bools

Rule
  channel-closed channel(_, _, Closed, _, _, _)
     ~> thread-atomic assigned Closed

Funcon
  channel-send(_:channels, _:values) : =>null-type


Rule
  channel-send(channel(Queue, N, Closed, _, AwaitingRecv, _), Val)
     ~> thread-atomic sequential(
          check-true and(
            not assigned Closed,
            is-greater(assigned N, 0),
            is-in-type([Val], variable-type Queue)),
          assign(N, integer-subtract(assigned N, 1)),
          assign(Queue, list-snoc(assigned Queue, Val)),
          finalise-failing condition-notify-first AwaitingRecv)

Funcon
  channel-send-else-wait(_:channels, _:values) : =>null-type

Rule
  channel-send-else-wait(Channel, Val)
     ~> sequential(
          channel-sync-else-wait Channel,
          if-true-else(
            channel-closed Channel,
            sequential(
              channel-release Channel,
              fail),
            else(
              sequential(
                channel-send(Channel, Val),
                channel-release Channel),
              sequential(
                channel-await-recv Channel),
                channel-send-else-wait(Channel, Val))))

Funcon
  channel-recv(_:channels) : =>values

Rule
  channel-recv channel(Queue, N, Closed, AwaitingSend, _, _)
     ~> thread-atomic sequential(
          check-true and(
            not assigned Closed,
            is-greater(list-length assigned Queue, 0)),
          give(
            list-head assigned Queue,
            sequential(
              assign(N, integer-add(assigned N, 1)),
              assign(Queue, list-tail assigned Queue),
              finalise-failing condition-notify-first AwaitingSend,
              given)))

Funcon
  channel-recv-else-wait(_:channels) : =>values

Rule
  channel-recv-else-wait Channel
     ~> sequential(
          channel-sync-else-wait Channel,
          if-true-else(
            channel-closed Channel,
            sequential(channel-release Channel, fail),
            else(
              passthrough(
                channel-recv Channel,
                channel-release Channel),
              sequential(
                channel-await-send Channel,
                channel-recv-else-wait Channel))))

