Language "Golang"

#B Funcons

Meta-variables
  T <: values

## Lists

Funcon
  list-snoc(_:lists(T), _:T) : => lists(T)

Rule
  list-snoc([V*:values*], V:values) ~> [V*, V]

Funcon
  list-init(_:lists(T)) : =>(lists(T))?

Rule
  list-init[V*:values*, _:values] ~> [V*]

Rule
  list-init[ ] ~> ( )

Funcon
  list-last(_:lists(T)) : =>(T)?

Rule
  list-last[_*:values*, V:values] ~> V

Rule
  list-last[ ] ~> ( )

Funcon
  lists-type(_:lists(_)) : =>types

Rule
  lists-type(lists(T)) ~> T


## Integers

//Alias
//  int-sub = integer-subtract


## Variables

Funcon
  variable-type(_:variables) : =>types

Rule
  variable-type variable(_:locations, T:types) ~> T


## Channels

Datatype
  channels(T) ::= channel(_:vars, _:vars _:vars, _:syncs, _:syncs)

Funcon
  channel-create(T, N:nats) : =>channels(T)
   ~> channel(
        alloc-init(lists(T), [ ]),
        alloc-init(nats, N),
        alloc-init(bools, false),
        condition-create,
        condition-create)

Funcon
  channel-type(_:channels(_)) : =>types

Rule
  channel-type channel(_*:values*, Var:variables, _:values)
    ~> lists-type variable-type Var

Funcon
  channel-send(_:channels(T), _:T) : =>null-type

Rule
  channel-send(channel(Queue, N, Closed, SendCond, ReceiveCond), X)
   ~> thread-atomic sequential(
        check-true not assigned Closed,
        check-true is-greater(assigned N, 0),
        sequential(
          assign(N, integer-subtract(assigned N, 1)),
          assign(Queue, list-snoc(assigned Queue, X)),
          condition-notify-first ReceiveCond))

Funcon
  channel-send-else-wait(_:channels(T), _:T) : =>null-type

Rule
  channel-send-else-wait(channel(Queue, N, Closed, SendCond, ReceiveCond), X)
   ~> thread-atomic handle-break while(
        true,
        else(
          sequential(
            channel-send(channel(Queue, N, Closed, SendCond, ReceiveCond)),
            break),
          sequential(
            check-true not assigned Closed,
            condition-wait SendCond)))

Funcon
  channel-receive(_:channels(T)) : =>T

Rule
  channel-receive(channel(Queue, N, Closed, SendCond, ReceiveCond))
   ~> thread-atomic sequential(
        check-true not assigned Closed,
        check-true is-greater(list-length assigned Queue, 0),
        give(
          list-head assigned Queue,
          sequential(
            assign(N, integer-add(N, 1)),
            assign(Queue, list-tail assigned Queue),
            condition-notify-first SendCond,
            given)))

Funcon
  channel-receive-else-wait(_:channels(T)) : =>T

Rule
  channel-receive-else-wait channel(Queue, N, Closed, SendCond, ReceiveCond)
   ~> thread-atomic handle-break while(
        true,
        else(
          sequential(
            channel-receive channel(Queue, N, Closed, SendCond, ReceiveCond),
            break),
          sequential(
            check-true not assigned Closed,
            condition-wait ReceiveCond)))




