Language "Golang"

#B Funcons

Meta-variables
  T <: values

## Lists

Funcon
  list-snoc(_:lists(T), _:T) : => lists(T)

Rule
  list-snoc([V*:values*], V:values) ~> [V*, V]

Funcon
  list-init(_:lists(T)) : =>(lists(T))?

Rule
  list-init[V*:values*, _:values] ~> [V*]

Rule
  list-init[ ] ~> ( )

Funcon
  list-last(_:lists(T)) : =>(T)?

Rule
  list-last[_*:values*, V:values] ~> V

Rule
  list-last[ ] ~> ( )


## Integers

//Alias
//  int-sub = integer-subtract


## Variables

Funcon
  variable-type(_:variables) : =>types

Rule
  variable-type variable(_:locations, T:types) ~> T


## Typeconstructs

Datatype
  type-constructs
    ::= {_:types} | type-construct(_:types, _:type-constructs*)

Funcon
  type-construct-type(_:type-constructs) : =>types

Rule
  type-construct-type(T:types) ~> T

Rule
  type-construct-type(type-construct(T:types, _*:type-constructs*)) ~> T

Funcon
  type-construct-args(_:type-constructs) : =>types*

Rule
  type-construct-args(_:types) ~> ( )

Rule
  type-construct-args(type-construct(_, Args*)) ~> Args*


## Channels

Datatype
  channels ::= channel(_:vars, _:vars, _:vars, _:syncs, _:syncs)

Funcon
  channel-create(T:types, N:nats) : =>channels
     ~> channel(
          alloc-init(lists(T), [ ]),
          alloc-init(nats, N),
          alloc-init(bools, false),
          condition-create,
          condition-create)

Funcon
  channel-send(_:channels, _:values) : =>null-type

Rule
  channel-send(channel(Queue, N, Closed, SendCond, ReceiveCond), Val)
     ~> thread-atomic checked when-true(
          and(
            not assigned Closed,
            is-in-type([Val], variable-type Queue),
            is-greater(assigned N, 0)),
          sequential(
            assign(N, integer-subtract(assigned N, 1)),
            assign(Queue, list-snoc(assigned Queue, Val)),
            finalise-failing condition-notify-first ReceiveCond))

Funcon
  channel-send-else-wait(_:channels, _:values) : =>null-type

Rule
  channel-send-else-wait(channel(Queue, N, Closed, SendCond, ReceiveCond), Val)
     ~> handle-return while(true,
          thread-atomic else(
            return channel-send(channel(Queue, N, Closed, SendCond, ReceiveCond), Val),
            sequential(
              check-true not assigned Closed,
              condition-wait SendCond)))

Funcon
  channel-receive(_:channels) : =>values

Rule
  channel-receive(channel(Queue, N, Closed, SendCond, ReceiveCond))
     ~> thread-atomic checked when-true(
          and(
            not assigned Closed,
            is-greater(list-length assigned Queue, 0)),
          give(
            list-head assigned Queue,
            sequential(
              assign(N, integer-add(N, 1)),
              assign(Queue, list-tail assigned Queue),
              finalise-failing condition-notify-first SendCond,
              given)))

Funcon
  channel-receive-else-wait(_:channels) : =>values

Rule
  channel-receive-else-wait channel(Queue, N, Closed, SendCond, ReceiveCond)
   ~> handle-return while(
        true,
        thread-atomic else(
          return channel-receive channel(Queue, N, Closed, SendCond, ReceiveCond),
          sequential(
            check-true not assigned Closed,
            condition-wait ReceiveCond)))

