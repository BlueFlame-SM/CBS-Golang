Language "Golang"

#B Funcons

## Strings

Funcon
  to-strings(_:values*) : =>strings*
Rule
  to-strings( ) ~> ( )
Rule
  to-strings(V:values, V*:values*)
   ~> (to-string V, to-strings V*)

## Channels

Datatype
  channels ::= channel(_:natural-numbers, _:variables, _:variables, _:variables)

Funcon
  channel-create(Size:natural-numbers) : =>channels
   ~> channel(Size,  // Size of the value buffer
        alloc-init(lists(values), []),  // Value buffer (queue)
        alloc-init(lists(pseudo-threads), []),  // Receiver queue
        alloc-init(lists(pseudo-threads), []))  // Sender queue

Funcon
  channel-print(C:channels) : =>null-type
   ~> print(structural-assigned C)

Funcon
  channel-send(C:channels, V:values) : =>null-type
   ~> thread-atomic else(
        channel-send-directly(C, V),
        channel-send-buffer(C, V))


Funcon
  channel-receive(C:channels) : =>values
   ~> thread-atomic else(
        channel-recv-buffer C,
        channel-recv-directly C)

Funcon
  channel-send-else-wait(C:channels, V:values) : =>null-type
   ~> sequential(
        thread-atomic else(
          channel-send(C, V),
          channel-send-wait(C, pseudo-thread-create(V))),
        postpone null)

Funcon
  channel-receive-else-wait(C:channels) : =>values
   ~> give(pseudo-thread-create( ),
        sequential(
          thread-atomic else(
            assign(pseudo-thread-value given, channel-receive C),
            channel-recv-wait(C, given)),
          postpone null,
          assigned pseudo-thread-value given))

Auxiliary Funcon
  channel-send-directly(C:channels, V:values) : =>null-type
Rule
  channel-send-directly(channel(_, _, RecvQ, _), V)
   ~> thread-atomic give(dequeue RecvQ,
        sequential(
          assign(pseudo-thread-value given, V),
          thread-resume pseudo-thread-id given))

Auxiliary Funcon
  channel-recv-directly(C:channels) : =>values
Rule
  channel-recv-directly channel(_, _, _, SendQ)
   ~> thread-atomic give(dequeue SendQ,
        sequential(
          thread-resume pseudo-thread-id given,
          assigned pseudo-thread-value given))

Auxiliary Funcon
  channel-send-buffer(_:channels, _:values) : =>null-type
Rule
  channel-send-buffer(channel(Size, Buffer, _, _), V)
   ~> thread-atomic sequential(
        check-true is-less(list-length assigned Buffer, Size),
        enqueue(Buffer, V))

Auxiliary Funcon
  channel-recv-buffer(_:channels) : =>values
Rule
  channel-recv-buffer channel(_, Buffer, _, SendQ)
   ~> thread-atomic after-effect(
        dequeue Buffer,
        finalise-failing give(dequeue SendQ,
          sequential(
            enqueue(Buffer, pseudo-thread-value given),
            thread-resume pseudo-thread-id given)))

Auxiliary Funcon
  channel-send-wait(_:channels, _:pseudo-threads) : =>null-type
Rule
  channel-send-wait(channel(_, _, _, SendQ), P)
   ~> thread-atomic sequential(
        enqueue(SendQ, P),
        thread-suspend current-thread)

Auxiliary Funcon
  channel-recv-wait(_:channels, _:pseudo-threads) : =>null-type
Rule
  channel-recv-wait(channel(_, _, RecvQ, _), P)
   ~> thread-atomic sequential(
        enqueue(RecvQ, P),
        thread-suspend current-thread)


Auxiliary Funcon
  dequeue(Q:variables) : =>values
   ~> after-effect(
        checked list-head assigned Q,
        assign(Q, checked list-tail assigned Q))

Auxiliary Funcon
  enqueue(Q:variables, V*:values) : =>null-type
   ~> assign(Q, list-append(assigned Q, [V*]))


Auxiliary Datatype
  pseudo-threads ::= pseudo-thread(_:variables, _:thread-ids)

Auxiliary Funcon
  pseudo-thread-create(_:values?) : =>pseudo-threads
Rule
  pseudo-thread-create( )
   ~> pseudo-thread(alloc(values), current-thread)
Rule
  pseudo-thread-create(V:values)
   ~> pseudo-thread(alloc-init(values, V), current-thread)

Auxiliary Funcon
  pseudo-thread-value(_:pseudo-threads) : =>variables
Rule
  pseudo-thread-value pseudo-thread(V, _) ~> V

Auxiliary Funcon
  pseudo-thread-id(_:pseudo-threads) : =>thread-ids
Rule
  pseudo-thread-id pseudo-thread(_, I) ~> I





//Datatype
//  channels
//    ::= channel(
//          Buffer : variables,
//          Size   : variables,
//          Closed : variables,
//          RecvQ  : syncs,
//          SendQ  : syncs,
//          Mutex  : syncs)
//
//Funcon
//  channel-create(Size:pos-ints) : =>channels
//   ~> channel(
//        alloc-init(lists values, [ ]),
//        alloc-init(pos-ints, Size),
//        alloc-init(bools, false),
//        condition-create,
//        condition-create,
//        exclusive-lock-create)
//
//Funcon
//  channel-send(_:channels, _:values) : =>null-type
//Rule
//  channel-send(channel(Buffer, Size, Closed, RecvQ, SendQ, Mutex), Values)
//   ~> finally(
//        sequential(
//          exclusive-lock-sync-else-wait(Mutex),
//          check-true not assigned(Closed),
//          when-true(
//            not is-condition-empty(SendQ),
//            sequential(
//              condition-wait-with-lock(SendQ, Mutex),
//              check-true not assigned(Closed))),
//          when-true(
//            is-greater-or-equal(list-length assigned(Buffer), assigned Size),
//            sequential(
//              condition-wait-head-with-lock(SendQ, Mutex),
//              check-true not assigned(Closed))),
//          assign(Buffer, list-append(assigned Buffer, [Values]))),
//        exclusive-lock-release(Mutex))
//
//Funcon
//  channel-receive(_:channels) : =>values
//Rule
//  channel-receive(channel(Buffer, Size, Closed, RecvQ, SendQ, Mutex))
//   ~> finally(
//        sequential(
//          exclusive-lock-sync-else-wait(Mutex),
//          check-true not assigned(Closed),
//          when-true(
//            not is-condition-empty(RecvQ),
//            sequential(
//              condition-wait-with-lock(RecvQ, Mutex),
//              check-true not assigned(Closed))),
//          when-tru),
//        exclusive-lock-release(Mutex))












