Language "Golang"

#B Funcons

Meta-variables
  T <: values

## Flowing

Funcon
  passthrough(Res:=>T, Comp*:(=>null-value)*) : =>T
     ~> give(Res, sequential(Comp*, given))


## Typeconstructs

Datatype
  type-constructs
    ::= {_:types} | type-construct(_:types, _:type-constructs*)

Funcon
  type-construct-type(_:type-constructs) : =>types

Rule
  type-construct-type(T:types) ~> T

Rule
  type-construct-type(type-construct(T:types, _*:type-constructs*)) ~> T

Funcon
  type-construct-args(_:type-constructs) : =>types*

Rule
  type-construct-args(_:types) ~> ( )

Rule
  type-construct-args(type-construct(_, Args*)) ~> Args*


## Exclusive locks

Funcon
  exclusive-lock-held(SY:syncs) : =>booleans
     ~> assigned sync-feature(SY, sync-held)

Funcon
  exclusive-lock-holder(SY:syncs) : =>thread-ids?
     ~> assigned sync-feature(SY, sync-holder)

Funcon
  exclusive-lock-owner(SY:syncs) : =>booleans
     ~> and(
          exclusive-lock-held SY,
          is-equal(exclusive-lock-holder SY, current-thread))


## Channels

Datatype
  pseudo-threads ::= pseudo-thread(
    ID     : thread-ids,
    Elem   : variables,
    Succes : variables)

Funcon
  pseudo-thread-create : =>pseudo-threads
     ~> pseudo-thread(
          current-thread,
          alloc variables,
          alloc booleans)

Funcon
  pseudo-thread-thread-id(_:pseudo-threads) : =>thread-ids
Rule
  pseudo-thread-thread-id pseudo-thread(ID, _, _) ~> ID

Funcon
  pseudo-thread-element(_:pseudo-threads) : =>thread-ids
Rule
  pseudo-thread-element pseudo-thread(_, Elem, _) ~> Elem




Datatype
  channels ::= channel(
    DataQ  : variables,
    Size   : variables,
    Closed : variables,
    RecvQ  : syncs,
    SendQ  : syncs,
    Mutex  : syncs)

Funcon
  channel-create(Size:nats) : =>channels
     ~> channel(
          alloc-init(lists values, [ ]),
          alloc-init(nats, Size),
          alloc-init(bools, false),
          condition-create,
          condition-create,
          exclusive-lock-create)

Funcon
  channel-sync-else-wait(_:channels) : =>null-type

Rule
  channel-sync-else-wait channel(_, _, _, _, _, Mutex)
     ~> exclusive-lock-sync-else-wait Mutex

Funcon
  channel-release(_:channels) : =>null-type

Rule
  channel-release channel(_, _, _, _, _, Mutex)
     ~> exclusive-lock-release Mutex

Funcon
  channel-closed(_:channels) : =>bools

Rule
  channel-closed channel(_, _, Closed, _, _, _)
     ~> thread-atomic assigned Closed

Rule
  channel-await-send channel(_, _, Closed, AwaitingSend, _, Mutex)
     ~> else(
          check-true assigned Closed,
          condition-wait-with-lock(AwaitingSend, Mutex))

Funcon
  channel-await-recv(_:channels) : =>null-type

Rule
  channel-await-recv channel(_, _, Closed, _, AwaitingRecv, Mutex)
     ~> else(
          check-true assigned Closed,
          condition-wait-with-lock(AwaitingRecv, Mutex))

Funcon
  channel-send(_:channels, _:values) : =>null-type

Rule
  channel-send(channel(Queue, Size, Closed, AwaitingSend, _, _), Val)
     ~> thread-atomic sequential(
          check-true and(
            not assigned Closed,
            is-less(list-length assigned Queue, assigned Size)),
          assign(Queue, list-append(assigned Queue, [Val])),
          finalise-failing condition-notify-first AwaitingSend)

Funcon
  channel-recv(_:channels) : =>values

Rule
  channel-recv channel(Queue, _, Closed, _, AwaitingRecv, _)
     ~> thread-atomic sequential(
          check-true and(
            not assigned Closed,
            is-greater(list-length assigned Queue, 0)),
          passthrough(
            list-head assigned Queue,
            assign(Queue, list-tail assigned Queue),
            finalise-failing condition-notify-first AwaitingRecv))

Funcon
  channel-await-send(_:channels) : =>null-type

Funcon
  channel-send-else-wait(_:channels, _:values) : =>null-type

Rule
  channel-send-else-wait(Channel, Val)
     ~> sequential(
          channel-sync-else-wait Channel,
          print(100),
          if-true-else(
            channel-closed Channel,
            sequential(print(200), channel-release Channel, fail),
            else(
              sequential(
                channel-send(Channel, Val),
                print(300),
                channel-release Channel),
              sequential(
                print(400),
                channel-await-recv Channel,
                print(500),
                channel-send-else-wait(Channel, Val)))))

Funcon
  channel-recv-else-wait(_:channels) : =>values

Rule
  channel-recv-else-wait Channel
     ~> sequential(
          channel-sync-else-wait Channel,
          if-true-else(
            channel-closed Channel,
            sequential(channel-release Channel, fail),
            else(
              passthrough(
                channel-recv Channel,
                channel-release Channel),
              sequential(
                channel-size-add(Channel, 1),
                channel-await-send Channel,
                channel-size-sub(Channel, 1),
                channel-recv-else-wait Channel))))
